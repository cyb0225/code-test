# code-test


## 题目要求

给定长度数组 S，有 M 个 worker 并发访问并更新 S, 每个 worker 重复如下操作：

随机生成 i, j （在 S 范围内），使 S[j] = S[i] + S[i + 1] + S[i + 2], 其中使用 i + 2 mod len(S) 避免数组越界。

**特殊情况**

- 注意读写锁的区别
- j 可能落在 S[i, i+2] 区间
- 如果出现死锁如何避免

## 初步思考

以数据库的视角来考虑这道题的话， S 就是一张表，M 是多个客户端来访问这张表

使用 select 查询出 S[i], S[i + 1], S[i + 2] 的数据，并使用 update 更新到 S[j] 可以看成一个完整的事务。


## 锁的粒度

如果直接对在整个 S 锁，类似串行化的隔离级别，那么处理起来会很方便，但是执行起来


## 更新对象与查询对象在同一个区间

即 j 可能与 i, i + 1, i + 2 中的任何一个相同

需要考虑的问题：

1. 要求保证一个事务里不会出现锁征用死锁的问题
2. 


## tow-phase locking 二阶段锁

加锁是每执行一条语句就往上加锁，但是锁的释放是在事务执行完毕后释放的。

二阶段锁，


## 死锁问题

### 死锁产生的例子

worker1 获取到的 j=4，i=1

worker2 获取到的 j=1，i=4

假设我们在操作时，依次获取 S[i], S[i+1], S[i+2], S[j] 的锁。

那么在这种情况下， worker1 先获取了 S[1], S[2], S[3] 的锁，worker2 先获取了 S[4],S[5],S[6] 的锁，没有发生锁冲突。
但是在 worker1 获取 S[j] 即 S[4] 时由于 worker2 已经持有锁了，所以开始等待锁释放。 
worker 在获取 S[1] 的时候也因为锁被 worker1 持有了，发生等待，所以产生死锁。

### demo

简单写了一个 demo 来印证这一点。

### 解决方式

首先需要检测出死锁，比如超时时间。

死锁等待超时

主动退避


